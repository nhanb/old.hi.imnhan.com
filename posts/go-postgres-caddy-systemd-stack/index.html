<!DOCTYPE html><html> <head><meta charset="utf-8"><title>Go, Postgres, Caddy, systemd: a simple, highly portable, Docker-free web stack | Hi, I'm Nhân</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="/theme/css/font.css"><link rel="stylesheet" href="/theme/css/pygment.css"><link rel="stylesheet" href="/theme/css/main.css"><link rel="stylesheet" href="/theme/css/article.css"><meta name="twitter:card" content="summary"><meta name="twitter:creator" content="@nhanbt"><meta property="og:title" content="Go, Postgres, Caddy, systemd: a simple, highly portable, Docker-free web stack"><meta property="og:description" content="I’ve mentioned before that I’m not a fan of Docker as a deployment strategy. In that same post I briefly mentioned that Go could simplify deployment compared to Python. Today I’ll go (haha get it?) into detail, warts and all, how I recently set up a publicly …"><meta property="og:image" content="../../images/keyboard-warrior.jpg"></head> <!--

Why hello there, source viewer. Here's a dragon for no particular reason:

       ^                       ^
       |\   \        /        /|
      /  \  |\__  __/|       /  \_
     / /\ \ \ _ \/ _ /      /    \_
    / / /\ \ {*}\/{*}      /  / \ \_
    | | | \ \( (00) )     /  // |\ \_
    | | | |\ \(V""V)\    /  / | || \|
    | | | | \ |^--^| \  /  / || || ||
   / / /  | |( WWWW__ \/  /| || || ||
  | | | | | |  \______\  / / || || ||
  | | | / | | )|______\ ) | / | || ||
  / / /  / /  /______/   /| \ \ || ||
 / / /  / /  /\_____/  |/ /__\ \ \ \ \_
 | | | / /  /\______/    \   \__| \ \ \_
 | | | | | |\______ __    \_    \__|_| \_
 | | ,___ /\______ _  _     \_       \  |
 | |/    /\_____  /    \      \__     \ |    /\_
 |/ |   |\______ |      |        \___  \ |__/  \_
 v  |   |\______ |      |            \___/     |
    |   |\______ |      |                    __/
     \   \________\_    _\               ____/
   __/   /\_____ __/   /   )\_,      _____/
  /  ___/  \____/  ___/___)    \______/
  VVV  V        VVV  V

(ripped off from http://www.retrojunkie.com/asciiart/myth/dragons.htm)

--> <body> <div id="main"> <header> <h1 id="site-name"><a href="/">Hi, I'm Nhân</a></h1> <h2 id="site-subtitle">and this is my humble corner on the intertubes.</h2> </header> <nav> <ul class="navbar" id="left-navbar"> <li><a href="/">Blog</a></li> <li><a href="../../about/">About</a></li> <li><a href="../../projects/">Projects</a></li> </ul> <ul class="navbar" id="right-navbar"> <li><a href="https://cv.imnhan.com">CV</a></li> <li><a href="/feeds/atom.xml">Feed</a></li> </ul> <div class="clearfix"></div> </nav> <div id="content"> <div class="article-content"> <article> <h1 class="article-title"> Go, Postgres, Caddy, systemd: a simple, highly portable, Docker-free web stack </h1> <time datetime="2023-02-12 14:24:00+07:00"> February 12, 2023 </time> <p>I&rsquo;ve <a href="/posts/i-made-my-python-webapp-pip-installable/">mentioned</a> before that I&rsquo;m not a fan of Docker as a deployment strategy. In that same post I briefly mentioned that Go could simplify deployment compared to Python. Today I&rsquo;ll <em>go</em> (haha get it?) into detail, warts and all, how I recently set up a publicly accessible Go web service, backed by a Postgres database, fronted by Caddy which does <span class="caps">TLS</span> termination <span class="amp">&amp;</span> automatic Let&rsquo;s Encrypt cert renewal, supervised <span class="amp">&amp;</span> isolated by&nbsp;systemd.</p> <h2 id="go">Go<a class="headerlink" href="#go" title="Permanent link">#</a></h2> <p>If you&rsquo;re new to Go like me, you may find it helpful to skim the book <a href="https://lets-go.alexedwards.net/">Let&rsquo;s Go</a> by Alex Edwards. It demonstrates helpful patterns so you can quickly put together a web service with little more than the Go standard library. However, it&rsquo;s cumbersome to define routes using only <code>net/http</code>, so I recommend using the very minimal <a href="https://www.alexedwards.net/blog/introducing-flow">flow</a> routing library written by the same author: it offers a cleaner <span class="caps">API</span> while having very little code itself. Heck, you should probably vendor it and later customize whichever way you&nbsp;want.</p> <p>As for the PostgreSQL driver, I chose <a href="https://github.com/lib/pq">github.com/lib/pq</a> simply because it&rsquo;s a pure Go library that implements the standard <code>database/sql</code> interface. I preferred to learn the most common <span class="caps">API</span> before branching into more special-purpose stuff. It quickly became tedious and error-prone to write all that boilerplate for reading data into Go structs though. I heard good things about <a href="https://sqlc.dev/">sqlc</a>, which generates Go code from <span class="caps">SQL</span> queries. I&rsquo;ll most likely try that&nbsp;next.</p> <p>Sticking to pure Go code brings 2 big benefits: <strong>independence from glibc</strong> and <strong>effortless cross-compilation</strong>.</p> <p>Not depending on glibc means our compiled executable for, say, Linux, will run, not only on any Linux distro regardless of its glibc version, but also on distros that use alternative libc implementations e.g. musl. Coming from Python, it&rsquo;s incredibly liberating to no longer have to find an ancient distro with the oldest possible glibc to build my executables on (most Python projects that do anything useful use C extensions, sadly). It&rsquo;s not without caveat though: some of Go&rsquo;s own standard libraries, namely <code>net</code> and <code>os/user</code>, use cgo by default. We can set <code>CGO_ENABLED=0</code> to avoid that, which tells the Go compiler to use their alternative pure Go implementations, but those are not as full-featured. If your code or dependency requires those, make sure to check if they work correctly with the pure Go version. The easiet way to confirm that your compiled executable is truly static is using either <code>ldd</code> or <code>file</code>:</p> <div class="highlight"><pre><span></span><code>$<span class="w"> </span>ldd<span class="w"> </span>mybinary
<span class="c1">#        not a dynamic executable</span>

$<span class="w"> </span>file<span class="w"> </span>mybinary<span class="w"> </span><span class="p">|</span><span class="w"> </span>tr<span class="w"> </span>,<span class="w"> </span><span class="s1">&#39;\n&#39;</span>
<span class="c1"># mybinary: ELF 64-bit LSB executable</span>
<span class="c1">#  x86-64</span>
<span class="c1">#  version 1 (SYSV)</span>
<span class="c1">#  statically linked</span>
<span class="c1">#  Go BuildID=[...]</span>
<span class="c1">#  with debug_info</span>
<span class="c1">#  not stripped</span>
</code></pre></div> <p>Cross-compilation is self-explanatory: out of the box, you can compile to any architecture/<span class="caps">OS</span> combination that Go supports. No more looking for the right <span class="caps">CI</span> service or docker container to build your stuff&nbsp;in.</p> <p>See&nbsp;also:</p> <ul> <li><a href="https://dave.cheney.net/2016/01/18/cgo-is-not-go">cgo is not Go</a>: a more exhaustive argument for staying in pure&nbsp;Go-land.</li> <li><a href="https://www.arp242.net/static-go.html">Statically compile Go programs</a>: a deep dive into static Go compilation and its quirks, complete with examples on how to statically link against SQLite with musl libc, if you&nbsp;must.</li> </ul> <h2 id="postgres">Postgres<a class="headerlink" href="#postgres" title="Permanent link">#</a></h2> <p>While SQLite is a fine choice for small-to-medium sites, it does have its own quirks: so-called <a href="https://www.sqlite.org/flextypegood.html">flexible type checking</a> and <a href="https://www.sqlite.org/lang_altertable.html#making_other_kinds_of_table_schema_changes">limited <span class="caps">ALTER</span> <span class="caps">TABLE</span> capabilities</a> are my two pet&nbsp;peeves.</p> <p>Postgres has none of those quirks, but causes extra operational complexity, not only for deployment, but also for development: you now need to erect a Postgres server with the right db/user/password combination for each&nbsp;project.</p> <p>From the local development perspective, this is actually one of the few cases where Docker rightfully shines: whip up a tiny docker-compose.yml, hit that <code>docker-compose up</code> command, and you&rsquo;ve got yourself a nicely isolated, delightfully disposable postgres server with your desired user/password/db combination, exposed at the exact port you&nbsp;want:</p> <div class="highlight"><pre><span></span><code><span class="c1"># docker-compose.yml</span>
<span class="nt">version</span><span class="p">:</span><span class="w"> </span><span class="s">&#39;3.9&#39;</span>
<span class="nt">services</span><span class="p">:</span>
<span class="w">  </span><span class="nt">db</span><span class="p">:</span>
<span class="w">    </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">postgres:15</span>
<span class="w">    </span><span class="nt">ports</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">127.0.0.1:5432:5432</span>
<span class="w">    </span><span class="nt">environment</span><span class="p">:</span>
<span class="w">      </span><span class="nt">POSTGRES_USER</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">example</span>
<span class="w">      </span><span class="nt">POSTGRES_PASSWORD</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">example</span>
<span class="w">      </span><span class="nt">POSTGRES_DB</span><span class="p">:</span><span class="w"> </span><span class="l l-Scalar l-Scalar-Plain">example</span>
</code></pre></div> <p>Since a developer&rsquo;s computer is typically not lacking in resources, we can get away with docker&rsquo;s storage overhead, and, in MacOS&rsquo;s case, <span class="caps">VM</span>&nbsp;overhead.</p> <p>But what if we want to stick to our anti-docker guns? Good news: it&rsquo;s still possible to have <a href="https://jamey.thesharps.us/2019/05/29/per-project-postgres/">Per-project Postgres</a> instances. Here&rsquo;s the&nbsp;gist:</p> <div class="highlight"><pre><span></span><code><span class="nb">cd</span><span class="w"> </span>my-project
mkdir<span class="w"> </span>.pgres<span class="w"> </span><span class="c1"># postgres data dir</span>

<span class="c1"># These envars tell postgres cli tools to:</span>
<span class="c1"># a) put data files in .pgres</span>
<span class="c1"># b) connect to server via a socket inside .pgres</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">PGDATA</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$PWD</span><span class="s2">/.pgres&quot;</span>
<span class="nb">export</span><span class="w"> </span><span class="nv">PGHOST</span><span class="o">=</span><span class="s2">&quot;</span><span class="nv">$PWD</span><span class="s2">/.pgres&quot;</span>

initdb<span class="w"> </span><span class="c1"># populate .pgres/</span>

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;listen_addresses = &#39;&#39;&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>.pgres/postgresql.conf
<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;unix_socket_directories = &#39;</span><span class="nv">$PGHOST</span><span class="s2">&#39;&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>.pgres/postgresql.conf

<span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;CREATE DATABASE </span><span class="nv">$USER</span><span class="s2">;&quot;</span><span class="w"> </span><span class="p">|</span><span class="w"> </span>postgres<span class="w"> </span>--single<span class="w"> </span>-E<span class="w"> </span>postgres
</code></pre></div> <p><em>(I also made a <a href="https://github.com/nhanb/neodots/blob/f79713b4e79c5da4fa92f75b1537b73b4c114d03/fish/scripts/standalone-postgres">python script</a> to automate this&nbsp;process)</em></p> <p>Now whenever you develop on this project, just cd into the project dir, make sure $<span class="caps">PGDATA</span> and $<span class="caps">PGHOST</span> point to the correct dir, then run <code>postgres</code>. You can save those environment variables into a <code>setenv.sh</code> script to source every time, or use tools like <a href="https://direnv.net/">direnv</a> to automatically set them on cd. When you no longer need it, cleaning up is as simple as removing the .pgres&nbsp;dir.</p> <p>On the server side, if you&rsquo;re on, say, Debian, the Postgres developers maintain an <a href="https://www.postgresql.org/download/linux/debian/">Apt repo</a> that provides any currently supported version of Postgres, so you can always use the latest and greatest <span class="caps">DB</span> while still enjoying the stability of Debian. Just follow the instructions to add the repo, install your preferred postgres version, then enable <span class="amp">&amp;</span> start the postgresql service using <code>systemctl</code>.</p> <p>You&rsquo;ll then need to follow the distro&rsquo;s <a href="https://wiki.debian.org/PostgreSql">convention</a> to create a <span class="caps">DB</span> with its dedicated username/password combination. Here&rsquo;s how I set up&nbsp;mine:</p> <div class="highlight"><pre><span></span><code>$<span class="w"> </span>su<span class="w"> </span>-<span class="w"> </span>postgres
<span class="o">(</span>as<span class="w"> </span>postgres<span class="o">)</span><span class="w"> </span>$<span class="w"> </span>createuser<span class="w"> </span>--pwprompt<span class="w"> </span>mypguser
<span class="o">(</span>as<span class="w"> </span>postgres<span class="o">)</span><span class="w"> </span>$<span class="w"> </span>createdb<span class="w"> </span>-O<span class="w"> </span>mypguser<span class="w"> </span>mypgdatabase
</code></pre></div> <p>I didn&rsquo;t bother to create a dedicated <span class="caps">OS</span> user, because I&rsquo;ll later use systemd&rsquo;s DynamicUser feature to run my service on its own dynamically created user anyway. This brings us&nbsp;to&hellip;</p> <h2 id="systemd">systemd<a class="headerlink" href="#systemd" title="Permanent link">#</a></h2> <p>Inevitably you&rsquo;ll need something to manage your service process: autostart on boot, report/restart when it goes down, piping logs to the right place, that sort of thing. People used to install things like <a href="http://supervisord.org/">supervisord</a> for that. (Docker Compose would kinda work too, but we&rsquo;re trying to see if we can avoid gratuitous container usage here,&nbsp;remember?)</p> <p>Nowadays though, systemd is already pervasive in mainstream Linux distros, and comes tightly integrated with supporting services e.g. journald, so it makes little sense to use anything else for service&nbsp;management.</p> <p>To limit the blast radius if (when?) a service gets pwn&rsquo;ed, it&rsquo;s recommended to run each service as its own <span class="caps">OS</span> user that only has access to what it actually needs. In the past I used to create 1 system user to run each service as, but this time I realized I could use systemd&rsquo;s <a href="https://0pointer.net/blog/dynamic-users-with-systemd.html">DynamicUser</a>&nbsp;instead:</p> <div class="highlight"><pre><span></span><code><span class="c1"># /etc/systemd/system/myservice.service</span>
<span class="k">[Service]</span>
<span class="na">ExecStart</span><span class="o">=</span><span class="s">/usr/local/bin/myservice</span>
<span class="na">Environment</span><span class="o">=</span><span class="s">MYSERVICE_DB=postgres://db-user:db-password@localhost/db-name</span>
<span class="na">Environment</span><span class="o">=</span><span class="s">MYSERVICE_ADDR=localhost:8000</span>
<span class="na">DynamicUser</span><span class="o">=</span><span class="s">1</span>
<span class="na">Restart</span><span class="o">=</span><span class="s">always</span>

<span class="k">[Install]</span>
<span class="na">WantedBy</span><span class="o">=</span><span class="s">multi-user.target</span>
</code></pre></div> <p>It&rsquo;s just a little less work compared to creating a system user with the correct restrictions and running the service under that user, but hey, less work is less work! Also that&rsquo;s one fewer thing that I have to worry about messing&nbsp;up.</p> <p>You may have noticed the <code>ExecStart=/usr/local/bin/myservice</code> line, which assumes my service&rsquo;s executable is in /usr/local/bin/. Since my service is only 1 binary with no support files, this, and postgres credentials (provided via the <code>MYSERVICE_DB</code> envar), are all that&rsquo;s needed to run the service. It also means for subsequent deployments, this will be my entire deployment&nbsp;procedure:</p> <div class="highlight"><pre><span></span><code><span class="c1"># compile:</span>
<span class="nv">CGO_ENABLED</span><span class="o">=</span><span class="m">0</span><span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>-o<span class="w"> </span>dist/myservice
<span class="c1"># copy binary to server (scp works too):</span>
rsync<span class="w"> </span>-av<span class="w"> </span>dist/myservice<span class="w"> </span>myserver:/usr/local/bin/myservice
<span class="c1"># restart service:</span>
ssh<span class="w"> </span>myserver<span class="w"> </span>systemctl<span class="w"> </span>restart<span class="w"> </span>myservice
</code></pre></div> <h2 id="caddy">Caddy<a class="headerlink" href="#caddy" title="Permanent link">#</a></h2> <p>Nowadays I prefer <a href="https://caddyserver.com/">Caddy</a> as the <span class="caps">TLS</span>-terminating reverse proxy instead of nginx, since it transparently performs Let&rsquo;s Encrypt&rsquo;s <span class="caps">ACME</span> challenge behind the scene. With my web service listening at localhost:8000, it literally takes 2 lines of config&nbsp;to:</p> <ul> <li>Serve <span class="caps">HTTPS</span> at port 443, with a valid cert provided by Let&rsquo;s Encrypt, using reasonable default cryptographic settings&mdash;I just ran my site through the <a href="https://www.ssllabs.com/ssltest/">ssllabs.com test</a> and it handily scored an&nbsp;A.</li> <li>Serve <span class="caps">HTTP</span> at port 80 that simply redirects to the <span class="caps">HTTPS</span>&nbsp;port</li> </ul> <div class="highlight"><pre><span></span><code><span class="c1"># /etc/caddy/Caddyfile</span>
<span class="k">my-domain.com</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kn">reverse_proxy</span><span class="w"> </span><span class="n">localhost</span><span class="p">:</span><span class="mi">8000</span>
<span class="err">}</span>
</code></pre></div> <p>There are many interesting problems to solve when running a web service, and <span class="caps">HTTPS</span> cert bookkeeping is not one of them, so I&rsquo;m more than happy to stop fiddling with certbot cron&nbsp;jobs.</p> <h2 id="closing-remarks">Closing remarks<a class="headerlink" href="#closing-remarks" title="Permanent link">#</a></h2> <p>For a proper production-grade service, there&rsquo;s more to be done: personally I&rsquo;m using <code>ufw</code> to lock down everything except for the <span class="caps">HTTP</span>(S) ports and wireguard (I&rsquo;m doing ssh over wireguard only too). Enabling unattended upgrades is also a good idea. But of course these depend heavily on each person&rsquo;s requirements and&nbsp;tastes.</p> <p>Of course I&rsquo;m not advocating for manual &ldquo;pet&rdquo; server maintenance everywhere. Nothing from this setup prevents you from doing proper automated provisioning, configuration management, so on and so forth. In fact, it is easier to e.g. write an ansible playbook for this setup, because it&rsquo;s simpler: you don&rsquo;t have to worry about setting up the correct python virtual environment, or making nginx and certbot play well with each other. Hell, you can dockerize parts of this setup, and your Dockerfiles will be simpler thanks to it. I&rsquo;ve <a href="/posts/i-made-my-python-webapp-pip-installable/">said it before</a>, and I&rsquo;ll say it&nbsp;again:</p> <blockquote> <p>Throwing abstractions over complex procedures is simply shifting the costs elsewhere. Shipping your software in a Dockerfile is fine, but making your distribution so simple that people can easily write a couple of lines of Dockerfile for it by themselves is more valuable. Simple distribution is simple to deploy regardless of whether you&rsquo;re using docker, packer, ansible, pyinfra, podman, nomad, k8s, k3s, an impenetrable shell script some dude wrote 2 years ago who just left the company last month&hellip; or any combination of the above. The point is <strong>you shouldn&rsquo;t be forced to use more heavyweight solutions just because the software is a pain in the butt to setup manually</strong>.</p> </blockquote> <p>Sooner or later we&rsquo;ll all have to peek under the hood to diagnose problems, and the fewer moving pieces you have to learn and understand, the more grateful you&rsquo;ll be to your predecessors (and, let&rsquo;s be honest, the fewer profanities you&rsquo;ll have to utter to&nbsp;yourself).</p> </article> </div> <h2 id="comments">Comments</h2> <div id="disqus_thread"> <button id="showCommentBtn">Show comments via Disqus</button> <noscript><br>(enable JavaScript first though)</noscript> </div> <script type="text/javascript">
    /* * * CONFIGURATION VARIABLES * * */
    // These need to be defined in the outermost scope, apparently.
    var disqus_shortname = 'nerdyweekly';
    var disqus_identifier = '/posts/go-postgres-caddy-systemd-stack/';
    var disqus_url = '../../posts/go-postgres-caddy-systemd-stack/';
    var disqus_title = 'Go, Postgres, Caddy, systemd: a simple, highly portable, Docker-free web stack';

    document.querySelector('#showCommentBtn').addEventListener('click', function (event) {
        // Immediate visual feedback is always good:
        event.target.disabled = true;
        event.target.innerHTML = 'Loading comments...';

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    });
</script> </div> <footer> &copy; 2013–2023 Bùi Thành Nhân <br> Built with &#9829; and probably too much <a target="_blank" rel="noopener" href="https://www.alambe.vn/products/ca-phe-rang-xay-alambe-sai-gon">cà phê sữa đá</a>. <p class="easter-egg" style="display: none; font-size: .7em; margin: 0; color: var(--bg-color);"> Bored? Try entering the Konami code from your keyboard. </p> <script>
        document.querySelector('.easter-egg').style.display = 'block';
      </script> </footer> </div> <script src="/theme/konami.js"></script> </body> </html>